import {
  IAction,
  IExtraArguments,
  IReduxState,
  QuestionType,
  IEditableAnswer,
  IEditablePoll, IEditableQuestion,
} from 'shared/types/app';
import { Dispatch } from 'redux';
import { IQuestionTemplate } from '../namespace';

function changeFieldValue(fieldName: string, fieldValue: string | number | boolean): IAction {
  return { type: 'CREATE_POLL:CHANGE_FIELD_VALUE', payload: { fieldName, fieldValue } };
}

function addQuestion(): IAction {
  return { type: 'CREATE_POLL:ADD_QUESTION' };
}

function addAnswer(questionIndex): IAction {
  return { type: 'CREATE_POLL:ADD_ANSWER', payload: questionIndex };
}

function changeAnswerText(questionIndex: number, answerIndex: number, value: string) {
  return { type: 'CREATE_POLL:CHANGE_ANSWER_TEXT', payload: { questionIndex, answerIndex, value } };
}

function changeQuestionType(questionIndex: number, value: QuestionType) {
  return {
    type: 'CREATE_POLL:CHANGE_QUESTION_FIELD',
    payload: { questionIndex, value, fieldName: 'type' },
  };
}

function changeQuestionText(questionIndex: number, value: string) {
  return {
    type: 'CREATE_POLL:CHANGE_QUESTION_FIELD',
    payload: { questionIndex, value, fieldName: 'text' },
  };
}

function savePoll() {
  return async(
    dispatch: Dispatch<any>, getState: () => IReduxState, { api }: IExtraArguments
  ) => {
    const poll: IEditablePoll = getState().createPoll.newPoll;
    const yesnoAnswers: IEditableAnswer [] = [{ text: 'Yes' }, { text: 'No' }];

    poll.questions = poll.questions.map(question => {
      if (question.type === 'YesNo') {
        return { ...question, answers: yesnoAnswers };
      } else {
        return question;
      }
    });

    dispatch({ type: 'CREATE_POLL:SEND_NEW_POLL' });

    try {
      if (poll.id) {
        api.updatePoll(poll);
      } else {
        api.createPoll(poll);
      }

      dispatch({ type: 'CREATE_POLL:SEND_NEW_POLL_SUCCESS' });
    } catch (error) {
      dispatch({ type: 'CREATE_POLL:SEND_NEW_POLL_FAILED', payload: error.message });
    }
  };
}

function loadPoll(id: string) {
  return async(
    dispatch: Dispatch<any>, getState: () => IReduxState, { api }: IExtraArguments
  ) => {
    dispatch({ type: 'CREATE_POLL:LOAD_POLL' });

    try {
      const poll = api.loadEditablePoll(id);
      dispatch({ type: 'CREATE_POLL:LOAD_POLL_SUCCESS', payload: poll });
    } catch (error) {
      dispatch({ type: 'CREATE_POLL:LOAD_POLL_SUCCESS', payload: error.message });
    }
  };
}

function removeCurrentPoll() {
  return async(
    dispatch: Dispatch<any>, getState: () => IReduxState, { api }: IExtraArguments
  ) => {
    const poll = getState().createPoll.newPoll;

    if (!poll || !poll.id) {
      return dispatch({ type: 'CREATE_POLL:REMOVE_POLL_FAIL', payload: 'Poll id is no defined' });
    }

    api.removePoll(poll.id);
    dispatch({ type: 'CREATE_POLL:REMOVE_POLL_SUCCESS' });
  };
}

function clearPollData(): IAction {
  return { type: 'CREATE_POLL:CLEAR_DATA' };
}

function generatePoll() {
  return (
    dispatch: Dispatch<any>, getState: () => IReduxState, { api }: IExtraArguments,
  ) => {
    const templates: IQuestionTemplate[] = getState().createPoll.questionsTemplates;
    const questions: IEditableQuestion[] = [];
    const questionsCount = getRandomInt(0, templates.length - 1);

    // generate questions array
    for (let i = 0; i < questionsCount; i++) {
      const template: IQuestionTemplate = templates[getRandomInt(0, templates.length - 1)];
      const question: IEditableQuestion = {
        text: template.text,
        type: 'SingleChoice',
        answers: template.answers.map<IEditableAnswer>((answer: string) => ({ text: answer })),
      };
      questions.push(question);
    }

    const poll: IEditablePoll = {
      questions,
      title: 'Randomly generated',
      description: 'It poll was generated by system.',
      isActive: true,
      startTime: new Date().toISOString().replace('Z', ''),
      endTime: (new Date(new Date().getTime() + 1000 * 60 * 60 * 24)).toISOString().replace('Z', ''),
    };

    api.createPoll(poll);
  };
}

function generatePolls(count: number) {
  return (dispatch: Dispatch<any>) => {
    for (let i = 0; i < count; i++) {
      dispatch(generatePoll());
    }
  };
}

function getRandomInt(min, max) {
  return Math.floor(Math.random() * (max - min)) + min;
}

export {
  removeCurrentPoll,
  generatePolls,
  generatePoll,
  clearPollData,
  changeQuestionText,
  changeQuestionType,
  changeAnswerText,
  changeFieldValue,
  addQuestion,
  savePoll,
  addAnswer,
  loadPoll,
}
